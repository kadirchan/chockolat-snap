{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://snap/javascript/node_modules/@metamask/utils/dist/chunk-H4YFDLB7.mjs","webpack://snap/javascript/node_modules/superstruct/dist/index.mjs","webpack://snap/javascript/node_modules/@metamask/utils/dist/chunk-CSDMTDND.mjs","webpack://snap/javascript/node_modules/@metamask/utils/dist/chunk-7S5AWFX7.mjs","webpack://snap/../node_modules/@metamask/snaps-ui/dist/esm/nodes.js","webpack://snap/../node_modules/@metamask/snaps-ui/dist/esm/builder.js","webpack://snap/../node_modules/@metamask/snaps-ui/dist/esm/validation.js","webpack://snap/../node_modules/fast-xml-parser/src/fxp.js","webpack://snap/../node_modules/fast-xml-parser/src/util.js","webpack://snap/../node_modules/fast-xml-parser/src/validator.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/node2json.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","webpack://snap/../node_modules/is-svg/index.js","webpack://snap/../node_modules/strnum/strnum.js","webpack://snap/webpack/bootstrap","webpack://snap/webpack/runtime/compat get default export","webpack://snap/webpack/runtime/define property getters","webpack://snap/webpack/runtime/hasOwnProperty shorthand","webpack://snap/webpack/runtime/make namespace object","webpack://snap/./src/index.ts"],"sourcesContent":["// src/misc.ts\nfunction isNonEmptyArray(value) {\n  return Array.isArray(value) && value.length > 0;\n}\nfunction isNullOrUndefined(value) {\n  return value === null || value === void 0;\n}\nfunction isObject(value) {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nvar hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nfunction getKnownPropertyNames(object) {\n  return Object.getOwnPropertyNames(object);\n}\nvar JsonSize = /* @__PURE__ */ ((JsonSize2) => {\n  JsonSize2[JsonSize2[\"Null\"] = 4] = \"Null\";\n  JsonSize2[JsonSize2[\"Comma\"] = 1] = \"Comma\";\n  JsonSize2[JsonSize2[\"Wrapper\"] = 1] = \"Wrapper\";\n  JsonSize2[JsonSize2[\"True\"] = 4] = \"True\";\n  JsonSize2[JsonSize2[\"False\"] = 5] = \"False\";\n  JsonSize2[JsonSize2[\"Quote\"] = 1] = \"Quote\";\n  JsonSize2[JsonSize2[\"Colon\"] = 1] = \"Colon\";\n  JsonSize2[JsonSize2[\"Date\"] = 24] = \"Date\";\n  return JsonSize2;\n})(JsonSize || {});\nvar ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\nfunction isASCII(character) {\n  return character.charCodeAt(0) <= 127;\n}\nfunction calculateStringSize(value) {\n  const size = value.split(\"\").reduce((total, character) => {\n    if (isASCII(character)) {\n      return total + 1;\n    }\n    return total + 2;\n  }, 0);\n  return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\nfunction calculateNumberSize(value) {\n  return value.toString().length;\n}\n\nexport {\n  isNonEmptyArray,\n  isNullOrUndefined,\n  isObject,\n  hasProperty,\n  getKnownPropertyNames,\n  JsonSize,\n  ESCAPE_CHARACTERS_REGEXP,\n  isPlainObject,\n  isASCII,\n  calculateStringSize,\n  calculateNumberSize\n};\n//# sourceMappingURL=chunk-H4YFDLB7.mjs.map","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","import {\n  getErrorMessage\n} from \"./chunk-7S5AWFX7.mjs\";\n\n// src/assert.ts\nimport { assert as assertSuperstruct } from \"superstruct\";\nfunction isConstructable(fn) {\n  return Boolean(typeof fn?.prototype?.constructor?.name === \"string\");\n}\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n  return getErrorMessage(error).replace(/\\.$/u, \"\");\n}\nfunction getError(ErrorWrapper, message) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message\n    });\n  }\n  return ErrorWrapper({\n    message\n  });\n}\nvar AssertionError = class extends Error {\n  constructor(options) {\n    super(options.message);\n    this.code = \"ERR_ASSERTION\";\n  }\n};\nfunction assert(value, message = \"Assertion failed.\", ErrorWrapper = AssertionError) {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n    throw getError(ErrorWrapper, message);\n  }\n}\nfunction assertStruct(value, struct, errorPrefix = \"Assertion failed\", ErrorWrapper = AssertionError) {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(\n      ErrorWrapper,\n      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`\n    );\n  }\n}\nfunction assertExhaustive(_object) {\n  throw new Error(\n    \"Invalid branch reached. Should be detected during compilation.\"\n  );\n}\n\nexport {\n  AssertionError,\n  assert,\n  assertStruct,\n  assertExhaustive\n};\n//# sourceMappingURL=chunk-CSDMTDND.mjs.map","import {\n  isNullOrUndefined,\n  isObject\n} from \"./chunk-H4YFDLB7.mjs\";\n\n// src/errors.ts\nimport { ErrorWithCause } from \"pony-cause\";\nfunction isError(error) {\n  return error instanceof Error || isObject(error) && error.constructor.name === \"Error\";\n}\nfunction isErrorWithCode(error) {\n  return typeof error === \"object\" && error !== null && \"code\" in error;\n}\nfunction isErrorWithMessage(error) {\n  return typeof error === \"object\" && error !== null && \"message\" in error;\n}\nfunction isErrorWithStack(error) {\n  return typeof error === \"object\" && error !== null && \"stack\" in error;\n}\nfunction getErrorMessage(error) {\n  if (isErrorWithMessage(error) && typeof error.message === \"string\") {\n    return error.message;\n  }\n  if (isNullOrUndefined(error)) {\n    return \"\";\n  }\n  return String(error);\n}\nfunction wrapError(originalError, message) {\n  if (isError(originalError)) {\n    const error = Error.length === 2 ? (\n      // This branch is getting tested by using the Node version that\n      // supports `cause` on the Error constructor.\n      // istanbul ignore next\n      // Also, for some reason `tsserver` is not complaining that the\n      // Error constructor doesn't support a second argument in the editor,\n      // but `tsc` does. I'm not sure why, but we disable this in the\n      // meantime.\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      new Error(message, { cause: originalError })\n    ) : new ErrorWithCause(message, { cause: originalError });\n    if (isErrorWithCode(originalError)) {\n      error.code = originalError.code;\n    }\n    return error;\n  }\n  if (message.length > 0) {\n    return new Error(`${String(originalError)}: ${message}`);\n  }\n  return new Error(String(originalError));\n}\n\nexport {\n  isErrorWithCode,\n  isErrorWithMessage,\n  isErrorWithStack,\n  getErrorMessage,\n  wrapError\n};\n//# sourceMappingURL=chunk-7S5AWFX7.mjs.map","import isSvg from 'is-svg';\nimport { array, assign, boolean, lazy, literal, object, optional, refine, string, union, unknown } from 'superstruct';\nconst NodeStruct = object({\n    type: string()\n});\nconst ParentStruct = assign(NodeStruct, object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(()=>ComponentStruct))\n}));\nconst LiteralStruct = assign(NodeStruct, object({\n    value: unknown()\n}));\nexport var NodeType;\n(function(NodeType) {\n    NodeType[\"Copyable\"] = 'copyable';\n    NodeType[\"Divider\"] = 'divider';\n    NodeType[\"Heading\"] = 'heading';\n    NodeType[\"Panel\"] = 'panel';\n    NodeType[\"Spinner\"] = 'spinner';\n    NodeType[\"Text\"] = 'text';\n    NodeType[\"Image\"] = 'image';\n})(NodeType || (NodeType = {}));\nexport const CopyableStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Copyable),\n    value: string()\n}));\nexport const DividerStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Divider)\n}));\nexport const HeadingStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Heading),\n    value: string()\n}));\nexport const PanelStruct = assign(ParentStruct, object({\n    type: literal(NodeType.Panel)\n}));\nexport const SpinnerStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Spinner)\n}));\nexport const TextStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean())\n}));\nconst SvgStruct = refine(string(), 'SVG', (value)=>{\n    if (!isSvg(value)) {\n        return 'Value is not a valid SVG.';\n    }\n    return true;\n});\nexport const ImageStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Image),\n    value: SvgStruct\n}));\nexport const ComponentStruct = union([\n    CopyableStruct,\n    DividerStruct,\n    HeadingStruct,\n    PanelStruct,\n    SpinnerStruct,\n    TextStruct,\n    ImageStruct\n]);\n\n//# sourceMappingURL=nodes.js.map","import { assertStruct, isPlainObject } from '@metamask/utils';\nimport { CopyableStruct, DividerStruct, HeadingStruct, ImageStruct, NodeType, PanelStruct, SpinnerStruct, TextStruct } from './nodes';\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n */ function createBuilder(type, struct, keys = []) {\n    return (...args)=>{\n        // Node passed as a single object.\n        if (args.length === 1 && isPlainObject(args[0])) {\n            const node = {\n                ...args[0],\n                type\n            };\n            // The user could be passing invalid values to the builder, so we need to\n            // validate them as per the component's struct.\n            assertStruct(node, struct, `Invalid ${type} component`);\n            return node;\n        }\n        // Node passed as an array of arguments.\n        const node = keys.reduce((partialNode, key, index)=>{\n            if (args[index] !== undefined) {\n                return {\n                    ...partialNode,\n                    [key]: args[index]\n                };\n            }\n            return partialNode;\n        }, {\n            type\n        });\n        // The user could be passing invalid values to the builder, so we need to\n        // validate them as per the component's struct.\n        assertStruct(node, struct, `Invalid ${type} component`);\n        return node;\n    };\n}\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.text - The text to copy.\n * @returns A {@link Copyable} component.\n */ export const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n    'value'\n]);\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @example\n * ```typescript\n * const node = divider();\n * ```\n */ export const divider = createBuilder(NodeType.Divider, DividerStruct);\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.text - The heading text.\n * @returns The heading node as object.\n * @example\n * ```typescript\n * const node = heading({ text: 'Hello, world!' });\n * const node = heading('Hello, world!');\n * ```\n */ export const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n    'value'\n]);\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @example\n * ```typescript\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n * ```\n */ export const panel = createBuilder(NodeType.Panel, PanelStruct, [\n    'children'\n]);\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @example\n * ```typescript\n * const node = spinner();\n * ```\n */ export const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable/disable markdown.\n * @returns The text node as object.\n * @example\n * ```typescript\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n * ```\n */ export const text = createBuilder(NodeType.Text, TextStruct, [\n    'value',\n    'markdown'\n]);\nexport const image = createBuilder(NodeType.Image, ImageStruct, [\n    'value'\n]);\n\n//# sourceMappingURL=builder.js.map","import { AssertionError, assert, assertStruct, hasProperty } from '@metamask/utils';\nimport { is } from 'superstruct';\nimport { ComponentStruct, NodeType } from './nodes';\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */ export function isComponent(value) {\n    return is(value, ComponentStruct);\n}\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */ export function assertIsComponent(value) {\n    assertStruct(value, ComponentStruct, 'Invalid component');\n}\nconst LINK_REGEX = RegExp(\"(?<protocol>[a-z]+:\\\\/?\\\\/?)(?<host>\\\\S+?(?:\\\\.[a-z]+)+)\", \"giu\");\nconst ALLOWED_PROTOCOLS = [\n    'https:',\n    'mailto:'\n];\n/**\n * Searches for links in a sting and checks them against the phishing list.\n *\n * @param text - The text to verify.\n * @param isOnPhishingList - The function that checks the link against the phishing list.\n */ export function assertLinksAreSafe(text, isOnPhishingList) {\n    const links = text.match(LINK_REGEX);\n    if (links) {\n        links.forEach((link)=>{\n            try {\n                const url = new URL(link);\n                assert(ALLOWED_PROTOCOLS.includes(url.protocol), `Protocol must be one of: ${ALLOWED_PROTOCOLS.join(', ')}.`);\n                const hostname = url.protocol === 'mailto:' ? url.pathname.split('@')[1] : url.hostname;\n                assert(!isOnPhishingList(hostname), 'The specified URL is not allowed.');\n            } catch (error) {\n                throw new Error(`Invalid URL: ${error instanceof AssertionError ? error.message : 'Unable to parse URL.'}`);\n            }\n        });\n    }\n}\n/**\n * Searches for links in UI components and checks that the URL they are trying to\n * pass in not in the phishing list.\n *\n * @param component - The custom UI component.\n * @param isOnPhishingList - The function that checks the link against the phishing list.\n */ export function assertUILinksAreSafe(component, isOnPhishingList) {\n    const { type } = component;\n    if (type === NodeType.Panel) {\n        component.children.forEach((node)=>assertUILinksAreSafe(node, isOnPhishingList));\n    }\n    if (hasProperty(component, 'value') && typeof component.value === 'string') {\n        assertLinksAreSafe(component.value, isOnPhishingList);\n    }\n}\n\n//# sourceMappingURL=validation.js.map","'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node\n    } else if (jObj[key] === null) {\n      if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup ){\n            listTagVal += this.j2x(item, level + 1).val;\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          listTagVal += this.buildTextValNode(item, key, '', level);\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, '', level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    if (attrStr && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n","const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n","\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;","'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\" },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if(val == undefined) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${tagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n    tagExp = tagExp.substr(separatorIndex + 1);\n  }\n\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n","const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;","'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n","'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;","'use strict';\nconst {XMLParser, XMLValidator} = require('fast-xml-parser');\n\nconst isSvg = input => {\n\tif (input === undefined || input === null) {\n\t\treturn false;\n\t}\n\n\tinput = input.toString().trim();\n\n\tif (input.length === 0) {\n\t\treturn false;\n\t}\n\n\t// Has to be `!==` as it can also return an object with error info.\n\tif (XMLValidator.validate(input) !== true) {\n\t\treturn false;\n\t}\n\n\tlet jsonObject;\n\tconst parser = new XMLParser();\n\n\ttry {\n\t\tjsonObject = parser.parse(input);\n\t} catch (_) {\n\t\treturn false;\n\t}\n\n\tif (!jsonObject) {\n\t\treturn false;\n\t}\n\n\tif (!('svg' in jsonObject)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nmodule.exports = isSvg;\n// TODO: Remove this for the next major release\nmodule.exports.default = isSvg;\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { OnRpcRequestHandler } from '@metamask/snaps-types';\nimport { panel, text } from '@metamask/snaps-ui';\n\n/**\n * Handle incoming JSON-RPC requests, sent through `wallet_invokeSnap`.\n *\n * @param args - The request handler args as object.\n * @param args.origin - The origin of the request, e.g., the website that\n * invoked the snap.\n * @param args.request - A validated JSON-RPC request object.\n * @returns The result of `snap_dialog`.\n * @throws If the request method is not valid for this snap.\n */\nexport const onRpcRequest: OnRpcRequestHandler = ({ origin, request }) => {\n  switch (request.method) {\n    case 'hello':\n      return snap.request({\n        method: 'snap_dialog',\n        params: {\n          type: 'confirmation',\n          content: panel([\n            text(`Hello, **${origin}**!`),\n            text('This custom confirmation is just for display purposes.'),\n            text(\n              'But you can edit the snap source code to make it do something, if you want to!',\n            ),\n          ]),\n        },\n      });\n    default:\n      throw new Error('Method not found.');\n  }\n};\n"],"names":["hasProperty","objectToCheck","name","Object","hasOwnProperty","call","JsonSize2","JsonSize","StructError","TypeError","constructor","failure","failures","cached","message","explanation","rest","path","msg","length","join","cause","assign","dist_isObject","x","print","value","toString","JSON","stringify","toFailure","result","context","struct","branch","type","refinement","key","toFailures","Symbol","iterator","r","run","options","coerce","mask","ctx","coercer","schema","Array","isArray","undefined","status","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Struct","props","assert","create","validate","is","tuples","tuple","input","done","next","shiftIterator","dist_assign","Structs","isType","schemas","map","object","dist_define","literal","constant","description","never","knowns","keys","Never","unknowns","delete","optional","string","unknown","refine","getErrorMessageWithoutTrailingPeriod","error","isErrorWithMessage","String","getErrorMessage","replace","getError","ErrorWrapper","fn","Boolean","prototype","AssertionError","Error","code","chunk_CSDMTDND_assert","assertStruct","errorPrefix","NodeStruct","ParentStruct","children","Element","lazy","ComponentStruct","i","slice","LiteralStruct","NodeType","CopyableStruct","Copyable","DividerStruct","Divider","HeadingStruct","Heading","PanelStruct","Panel","SpinnerStruct","Spinner","TextStruct","Text","markdown","SvgStruct","is_svg_default","ImageStruct","Image","S","coerced","first","push","union","createBuilder","args","proto","getPrototypeOf","_","isPlainObject","node","reduce","partialNode","index","copyable","divider","heading","panel","spinner","builder_text","builder_image","isComponent","assertIsComponent","LINK_REGEX","RegExp","ALLOWED_PROTOCOLS","assertLinksAreSafe","text","isOnPhishingList","links","match","forEach","link","url","URL","includes","protocol","hostname","pathname","split","assertUILinksAreSafe","component","__webpack_require__","XMLParser","XMLBuilder","module","exports","XMLValidator","nameStartChar","nameRegexp","regexName","isExist","isEmptyObject","obj","merge","target","a","arrayMode","len","getValue","isName","exec","getAllMatches","regex","matches","allmatches","startIndex","lastIndex","util","defaultOptions","allowBooleanAttributes","unpairedTags","isWhiteSpace","char","readPI","xmlData","start","tagname","substr","getErrorObject","getLineNumberForPosition","readCommentAndCDATA","angleBracketsCount","tags","tagFound","reachedRoot","err","tagStartPos","closingTag","tagName","trim","substring","readAttributeStr","attrStr","attrStrStart","isValid","validateAttributeString","line","tagClosed","otg","pop","openPos","col","indexOf","afterAmp","validateAmpersand","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","getPositionFromMatch","attrName","validateAttrName","re","validateNumberAmpersand","count","lineNumber","lines","buildFromOrderedJs","attributeNamePrefix","attributesGroupName","textNodeName","ignoreAttributes","cdataPropName","format","indentBy","suppressEmptyNode","suppressUnpairedNode","suppressBooleanAttributes","tagValueProcessor","attributeValueProcessor","preserveOrder","commentPropName","entities","val","processEntities","stopNodes","oneListGroup","Builder","isAttribute","attrPrefixLen","processTextOrObjNode","indentate","tagEndChar","newLine","level","j2x","buildTextValNode","buildObjectNode","repeat","startsWith","build","jObj","arrayNodeName","Date","attr","buildAttrPairStr","newval","replaceEntitiesValue","arrLen","listTagVal","j","item","Ks","L","closeTag","tagEndExp","piClosingChar","textValue","entity","arrToStr","arr","jPath","indentation","xmlStr","isPreviousElementTag","tagObj","propName","newJPath","tagText","isStopNode","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","endsWith","attrMap","attrVal","lastIndexOf","jArray","readEntityExp","entityName","isComment","isEntity","isElement","isAttlist","isNotation","validateEntityName","hasBody","comment","exp","regx","removeNSPrefix","parseTagValue","parseAttributeValue","trimValues","numberParseOptions","hex","leadingZeros","eNotation","alwaysCreateTextNode","htmlEntities","ignoreDeclaration","ignorePiTags","transformTagName","transformAttributeName","updateTag","attrs","buildOptions","xmlNode","readDocType","toNumber","addExternalEntities","externalEntities","entKeys","ent","lastEntities","parseTextData","dontTrim","hasAttributes","isLeafNode","escapeEntities","parseValue","resolveNameSpace","prefix","charAt","attrsRegx","buildAttributesMap","oldVal","aName","newVal","attrCollection","parseXml","xmlObj","currentNode","textData","closeIndex","findClosingIndex","colonIndex","saveTextToParentTag","lastTagName","propIndex","tagsNodeStack","tagData","readTagExp","childNode","tagExp","attrExpPresent","addChild","endIndex","this","docTypeEntities","lastTag","isItStopNode","tagContent","readStopNodeData","child","ampEntity","currentTagName","allNodesExp","stopNodePath","stopNodeExp","str","errMsg","closingIndex","closingChar","attrBoundary","ch","data","tagExpWithClosingIndex","separatorIndex","search","openTagCount","shouldParse","OrderedObjParser","prettify","parse","validationOption","orderedObjParser","orderedResult","addEntity","compress","compressedObj","property","newJpath","isLeaf","isLeafTag","assignAttributes","jpath","atrrName","propCount","isSvg","jsonObject","parser","hexRegex","numRegex","Number","parseInt","window","parseFloat","consider","decimalPoint","trimmedStr","skipLike","test","sign","numTrimmedByZeros","numStr","trimZeros","num","__webpack_module_cache__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","prop","toStringTag","onRpcRequest","origin","request","method","snap","params","content","_snapsui"],"sourceRoot":""}